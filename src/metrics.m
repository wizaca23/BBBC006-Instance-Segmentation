%A MATLAB Toolbox%%Compare two segmentation results using%1. Global Consistency Error%2. Boundary Displacement Error%%IMPORTANT: The two input images must have the same size!%%Authors: John Wright, and Allen Y. Yang%Contact: Allen Y. Yang <yang@eecs.berkeley.edu>%%(c) Copyright. University of California, Berkeley. 2007.%%Notice: The packages should NOT be used for any commercial purposes%without direct consent of their author(s). The authors are not responsible%for any potential property loss or damage caused directly or indirectly by the usage of the software.pkg load imageclearwarning("off", "all")%Functions required for the calculationsfunction gce = GlobalConsistencyError(sampleLabels1,sampleLabels2)    [imWidth,imHeight]=size(sampleLabels1);    [imWidth2,imHeight2]=size(sampleLabels2);    N=imWidth*imHeight;    if (imWidth~=imWidth2)||(imHeight~=imHeight2)        disp( 'Input sizes: ' );        disp( size(sampleLabels1) );        disp( size(sampleLabels2) );        error('Input sizes do not match in compare_segmentations.m');    end    % make the group indices start at 1    if min(min(sampleLabels1)) < 1        sampleLabels1 = sampleLabels1 - min(min(sampleLabels1)) + 1;    end    if min(min(sampleLabels2)) < 1        sampleLabels2 = sampleLabels2 - min(min(sampleLabels2)) + 1;    end    segmentcount1=max(max(sampleLabels1));    segmentcount2=max(max(sampleLabels2));    % compute the count matrix    %  from this we can quickly compute rand index, GCE, VOI, ect...    n=zeros(segmentcount1,segmentcount2);    for i=1:imWidth        for j=1:imHeight            u=sampleLabels1(i,j);            v=sampleLabels2(i,j);            n(u,v)=n(u,v)+1;        end    end    gce = global_consistancy_error(n);end% global consistancy error (from BSDS ICCV 01 paper) ... lower => betterfunction gce = global_consistancy_error(n)    N = sum(sum(n));    marginal_1 = sum(n,2);    marginal_2 = sum(n,1);    % the hackery is to protect against cases where some of the marginals are    % zero (should never happen, but seems to...)    E1 = 1 - sum( sum(n.*n,2) ./ (marginal_1 + (marginal_1 == 0)) ) / N;    E2 = 1 - sum( sum(n.*n,1) ./ (marginal_2 + (marginal_2 == 0)) ) / N;    gce = min( E1, E2 );endfunction loss = dice_multi(new_img, T)  % loss = dice_multi(Y, T) returns the Dice loss between  % the predictions Y and the training targets T.     weights = [0.3, 0.3, 0.4];    new_img = new_img/255;  T = T/255;    dice_class_1 = dice(new_img(:,:,1), T(:,:,1));  dice_class_2 = dice(new_img(:,:,2), T(:,:,2));  dice_class_3 = dice(new_img(:,:,3), T(:,:,3));  loss = dice_class_1 * weights(1) + dice_class_2 * weights(2) + dice_class_3 * weights(3);endfunction z = dice(Y,T)  z = 2*nnz(Y&T)/(nnz(Y) + nnz(T));  if (isnan(z))      z = 1;  endendfunction averageError = compare_image_boundary_error(imageLabels1, imageLabels2)    [imageX, imageY] = size(imageLabels1);    if imageX~=size(imageLabels2,1) | imageY~=size(imageLabels2,2)        error('The sizes of the two comparing images must be the same.');    end    if isempty(find(imageLabels1~=imageLabels1(1)))        % imageLabels1 only has one group        boundary1 = zeros(size(imageLabels1));        boundary1(1,:) = 1;        boundary1(:,1) = 1;        boundary1(end,:) = 1;        boundary1(:,end) = 1;    else        % Generate boundary maps        [cx,cy] = gradient(imageLabels1);        [boundaryPixelX{1},boundaryPixelY{1}] = find((abs(cx)+abs(cy))~=0);        boundary1 = abs(cx) + abs(cy) > 0;    end    if isempty(find(imageLabels2~=imageLabels2(1)))        % imageLabels2 only has one group        boundary2 = zeros(size(imageLabels2));        boundary2(1,:) = 1;        boundary2(:,1) = 1;        boundary2(end,:) = 1;        boundary2(:,end) = 1;        else            % Generate boundary maps        [cx,cy] = gradient(imageLabels2);        [boundaryPixelX{2},boundaryPixelY{2}] = find((abs(cx)+abs(cy))~=0);        boundary2 = abs(cx) + abs(cy) > 0;    end    % boundary1 and boundary2 are now binary boundary masks. compute their    % distance transforms:    D1 = bwdist(boundary1);    D2 = bwdist(boundary2);    % compute the distance of the pixels in boundary1 to the nearest pixel in    % boundary2:    dist_12 = sum(sum(boundary1 .* D2 ));    dist_21 = sum(sum(boundary2 .* D1 ));    avgError_12 = dist_12 / sum(sum(boundary1));    avgError_21 = dist_21 / sum(sum(boundary2));    averageError = (avgError_12 + avgError_21) / 2;end